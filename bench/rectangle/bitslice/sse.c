/* This code was generated by Usuba.
   See https://github.com/DadaIsCrazy/usuba.
   From the file "samples/usuba/rectangle_bitslice.ua" (included below). */

#include <stdint.h>

/* Do NOT change the order of those define/include */

#ifndef BITS_PER_REG
#define BITS_PER_REG 128
#endif
/* including the architecture specific .h */
#include "SSE.h"

/* auxiliary functions */
void SubColumn_single__B1 (/*inputs*/ DATATYPE a0__,DATATYPE a1__,DATATYPE a2__,DATATYPE a3__, /*outputs*/ DATATYPE* b0__,DATATYPE* b1__,DATATYPE* b2__,DATATYPE* b3__) {

  // Variables declaration
  DATATYPE t1__;
  DATATYPE t11__;
  DATATYPE t2__;
  DATATYPE t3__;
  DATATYPE t5__;
  DATATYPE t6__;
  DATATYPE t8__;
  DATATYPE t9__;

  // Instructions (body)
  t1__ = NOT(a1__);
  t3__ = XOR(a2__,a3__);
  t8__ = XOR(a1__,a2__);
  t2__ = AND(a0__,t1__);
  t5__ = OR(a3__,t1__);
  *b0__ = XOR(t2__,t3__);
  t6__ = XOR(a0__,t5__);
  t11__ = OR(*b0__,t8__);
  *b1__ = XOR(a2__,t6__);
  t9__ = AND(t3__,t6__);
  *b2__ = XOR(t6__,t11__);
  *b3__ = XOR(t8__,t9__);

}

/* main function */
void Rectangle__ (/*inputs*/ DATATYPE plain__[64],DATATYPE key__[26][64], /*outputs*/ DATATYPE cipher__[64]) {

  // Variables declaration
  DATATYPE _tmp1_[64];
  DATATYPE _tmp2_[64];
  DATATYPE tmp__[64];

  // Instructions (body)
  tmp__[0] = plain__[0];
  tmp__[1] = plain__[1];
  tmp__[2] = plain__[2];
  tmp__[3] = plain__[3];
  tmp__[4] = plain__[4];
  tmp__[5] = plain__[5];
  tmp__[6] = plain__[6];
  tmp__[7] = plain__[7];
  tmp__[8] = plain__[8];
  tmp__[9] = plain__[9];
  tmp__[10] = plain__[10];
  tmp__[11] = plain__[11];
  tmp__[12] = plain__[12];
  tmp__[13] = plain__[13];
  tmp__[14] = plain__[14];
  tmp__[15] = plain__[15];
  tmp__[16] = plain__[16];
  tmp__[17] = plain__[17];
  tmp__[18] = plain__[18];
  tmp__[19] = plain__[19];
  tmp__[20] = plain__[20];
  tmp__[21] = plain__[21];
  tmp__[22] = plain__[22];
  tmp__[23] = plain__[23];
  tmp__[24] = plain__[24];
  tmp__[25] = plain__[25];
  tmp__[26] = plain__[26];
  tmp__[27] = plain__[27];
  tmp__[28] = plain__[28];
  tmp__[29] = plain__[29];
  tmp__[30] = plain__[30];
  tmp__[31] = plain__[31];
  tmp__[32] = plain__[32];
  tmp__[33] = plain__[33];
  tmp__[34] = plain__[34];
  tmp__[35] = plain__[35];
  tmp__[36] = plain__[36];
  tmp__[37] = plain__[37];
  tmp__[38] = plain__[38];
  tmp__[39] = plain__[39];
  tmp__[40] = plain__[40];
  tmp__[41] = plain__[41];
  tmp__[42] = plain__[42];
  tmp__[43] = plain__[43];
  tmp__[44] = plain__[44];
  tmp__[45] = plain__[45];
  tmp__[46] = plain__[46];
  tmp__[47] = plain__[47];
  tmp__[48] = plain__[48];
  tmp__[49] = plain__[49];
  tmp__[50] = plain__[50];
  tmp__[51] = plain__[51];
  tmp__[52] = plain__[52];
  tmp__[53] = plain__[53];
  tmp__[54] = plain__[54];
  tmp__[55] = plain__[55];
  tmp__[56] = plain__[56];
  tmp__[57] = plain__[57];
  tmp__[58] = plain__[58];
  tmp__[59] = plain__[59];
  tmp__[60] = plain__[60];
  tmp__[61] = plain__[61];
  tmp__[62] = plain__[62];
  tmp__[63] = plain__[63];
  for (int i__ = 0; i__ <= 24; i__++) {
    _tmp1_[0] = XOR(tmp__[0],key__[i__][0]);
    _tmp1_[1] = XOR(tmp__[1],key__[i__][1]);
    _tmp1_[2] = XOR(tmp__[2],key__[i__][2]);
    _tmp1_[3] = XOR(tmp__[3],key__[i__][3]);
    _tmp1_[4] = XOR(tmp__[4],key__[i__][4]);
    _tmp1_[5] = XOR(tmp__[5],key__[i__][5]);
    _tmp1_[6] = XOR(tmp__[6],key__[i__][6]);
    _tmp1_[7] = XOR(tmp__[7],key__[i__][7]);
    _tmp1_[8] = XOR(tmp__[8],key__[i__][8]);
    _tmp1_[9] = XOR(tmp__[9],key__[i__][9]);
    _tmp1_[10] = XOR(tmp__[10],key__[i__][10]);
    _tmp1_[11] = XOR(tmp__[11],key__[i__][11]);
    _tmp1_[12] = XOR(tmp__[12],key__[i__][12]);
    _tmp1_[13] = XOR(tmp__[13],key__[i__][13]);
    _tmp1_[14] = XOR(tmp__[14],key__[i__][14]);
    _tmp1_[15] = XOR(tmp__[15],key__[i__][15]);
    _tmp1_[16] = XOR(tmp__[16],key__[i__][16]);
    _tmp1_[17] = XOR(tmp__[17],key__[i__][17]);
    _tmp1_[18] = XOR(tmp__[18],key__[i__][18]);
    _tmp1_[19] = XOR(tmp__[19],key__[i__][19]);
    _tmp1_[20] = XOR(tmp__[20],key__[i__][20]);
    _tmp1_[21] = XOR(tmp__[21],key__[i__][21]);
    _tmp1_[22] = XOR(tmp__[22],key__[i__][22]);
    _tmp1_[23] = XOR(tmp__[23],key__[i__][23]);
    _tmp1_[24] = XOR(tmp__[24],key__[i__][24]);
    _tmp1_[25] = XOR(tmp__[25],key__[i__][25]);
    _tmp1_[26] = XOR(tmp__[26],key__[i__][26]);
    _tmp1_[27] = XOR(tmp__[27],key__[i__][27]);
    _tmp1_[28] = XOR(tmp__[28],key__[i__][28]);
    _tmp1_[29] = XOR(tmp__[29],key__[i__][29]);
    _tmp1_[30] = XOR(tmp__[30],key__[i__][30]);
    _tmp1_[31] = XOR(tmp__[31],key__[i__][31]);
    _tmp1_[32] = XOR(tmp__[32],key__[i__][32]);
    _tmp1_[33] = XOR(tmp__[33],key__[i__][33]);
    _tmp1_[34] = XOR(tmp__[34],key__[i__][34]);
    _tmp1_[35] = XOR(tmp__[35],key__[i__][35]);
    _tmp1_[36] = XOR(tmp__[36],key__[i__][36]);
    _tmp1_[37] = XOR(tmp__[37],key__[i__][37]);
    _tmp1_[38] = XOR(tmp__[38],key__[i__][38]);
    _tmp1_[39] = XOR(tmp__[39],key__[i__][39]);
    _tmp1_[40] = XOR(tmp__[40],key__[i__][40]);
    _tmp1_[41] = XOR(tmp__[41],key__[i__][41]);
    _tmp1_[42] = XOR(tmp__[42],key__[i__][42]);
    _tmp1_[43] = XOR(tmp__[43],key__[i__][43]);
    _tmp1_[44] = XOR(tmp__[44],key__[i__][44]);
    _tmp1_[45] = XOR(tmp__[45],key__[i__][45]);
    _tmp1_[46] = XOR(tmp__[46],key__[i__][46]);
    _tmp1_[47] = XOR(tmp__[47],key__[i__][47]);
    _tmp1_[48] = XOR(tmp__[48],key__[i__][48]);
    _tmp1_[49] = XOR(tmp__[49],key__[i__][49]);
    _tmp1_[50] = XOR(tmp__[50],key__[i__][50]);
    _tmp1_[51] = XOR(tmp__[51],key__[i__][51]);
    _tmp1_[52] = XOR(tmp__[52],key__[i__][52]);
    _tmp1_[53] = XOR(tmp__[53],key__[i__][53]);
    _tmp1_[54] = XOR(tmp__[54],key__[i__][54]);
    _tmp1_[55] = XOR(tmp__[55],key__[i__][55]);
    _tmp1_[56] = XOR(tmp__[56],key__[i__][56]);
    _tmp1_[57] = XOR(tmp__[57],key__[i__][57]);
    _tmp1_[58] = XOR(tmp__[58],key__[i__][58]);
    _tmp1_[59] = XOR(tmp__[59],key__[i__][59]);
    _tmp1_[60] = XOR(tmp__[60],key__[i__][60]);
    _tmp1_[61] = XOR(tmp__[61],key__[i__][61]);
    _tmp1_[62] = XOR(tmp__[62],key__[i__][62]);
    _tmp1_[63] = XOR(tmp__[63],key__[i__][63]);
    for (int i__1 = 0; i__1 <= 15; i__1++) {
      SubColumn_single__B1(_tmp1_[i__1],_tmp1_[(i__1 + 16)],_tmp1_[(i__1 + 32)],_tmp1_[(i__1 + 48)],&_tmp2_[i__1],&_tmp2_[(i__1 + 16)],&_tmp2_[(i__1 + 32)],&_tmp2_[(i__1 + 48)]);
    }
    tmp__[0] = _tmp2_[0];
    tmp__[1] = _tmp2_[1];
    tmp__[2] = _tmp2_[2];
    tmp__[3] = _tmp2_[3];
    tmp__[4] = _tmp2_[4];
    tmp__[5] = _tmp2_[5];
    tmp__[6] = _tmp2_[6];
    tmp__[7] = _tmp2_[7];
    tmp__[8] = _tmp2_[8];
    tmp__[9] = _tmp2_[9];
    tmp__[10] = _tmp2_[10];
    tmp__[11] = _tmp2_[11];
    tmp__[12] = _tmp2_[12];
    tmp__[13] = _tmp2_[13];
    tmp__[14] = _tmp2_[14];
    tmp__[15] = _tmp2_[15];
    tmp__[16] = _tmp2_[17];
    tmp__[17] = _tmp2_[18];
    tmp__[18] = _tmp2_[19];
    tmp__[19] = _tmp2_[20];
    tmp__[20] = _tmp2_[21];
    tmp__[21] = _tmp2_[22];
    tmp__[22] = _tmp2_[23];
    tmp__[23] = _tmp2_[24];
    tmp__[24] = _tmp2_[25];
    tmp__[25] = _tmp2_[26];
    tmp__[26] = _tmp2_[27];
    tmp__[27] = _tmp2_[28];
    tmp__[28] = _tmp2_[29];
    tmp__[29] = _tmp2_[30];
    tmp__[30] = _tmp2_[31];
    tmp__[31] = _tmp2_[16];
    tmp__[32] = _tmp2_[44];
    tmp__[33] = _tmp2_[45];
    tmp__[34] = _tmp2_[46];
    tmp__[35] = _tmp2_[47];
    tmp__[36] = _tmp2_[32];
    tmp__[37] = _tmp2_[33];
    tmp__[38] = _tmp2_[34];
    tmp__[39] = _tmp2_[35];
    tmp__[40] = _tmp2_[36];
    tmp__[41] = _tmp2_[37];
    tmp__[42] = _tmp2_[38];
    tmp__[43] = _tmp2_[39];
    tmp__[44] = _tmp2_[40];
    tmp__[45] = _tmp2_[41];
    tmp__[46] = _tmp2_[42];
    tmp__[47] = _tmp2_[43];
    tmp__[48] = _tmp2_[61];
    tmp__[49] = _tmp2_[62];
    tmp__[50] = _tmp2_[63];
    tmp__[51] = _tmp2_[48];
    tmp__[52] = _tmp2_[49];
    tmp__[53] = _tmp2_[50];
    tmp__[54] = _tmp2_[51];
    tmp__[55] = _tmp2_[52];
    tmp__[56] = _tmp2_[53];
    tmp__[57] = _tmp2_[54];
    tmp__[58] = _tmp2_[55];
    tmp__[59] = _tmp2_[56];
    tmp__[60] = _tmp2_[57];
    tmp__[61] = _tmp2_[58];
    tmp__[62] = _tmp2_[59];
    tmp__[63] = _tmp2_[60];
  }
  cipher__[0] = XOR(tmp__[0],key__[25][0]);
  cipher__[1] = XOR(tmp__[1],key__[25][1]);
  cipher__[2] = XOR(tmp__[2],key__[25][2]);
  cipher__[3] = XOR(tmp__[3],key__[25][3]);
  cipher__[4] = XOR(tmp__[4],key__[25][4]);
  cipher__[5] = XOR(tmp__[5],key__[25][5]);
  cipher__[6] = XOR(tmp__[6],key__[25][6]);
  cipher__[7] = XOR(tmp__[7],key__[25][7]);
  cipher__[8] = XOR(tmp__[8],key__[25][8]);
  cipher__[9] = XOR(tmp__[9],key__[25][9]);
  cipher__[10] = XOR(tmp__[10],key__[25][10]);
  cipher__[11] = XOR(tmp__[11],key__[25][11]);
  cipher__[12] = XOR(tmp__[12],key__[25][12]);
  cipher__[13] = XOR(tmp__[13],key__[25][13]);
  cipher__[14] = XOR(tmp__[14],key__[25][14]);
  cipher__[15] = XOR(tmp__[15],key__[25][15]);
  cipher__[16] = XOR(tmp__[16],key__[25][16]);
  cipher__[17] = XOR(tmp__[17],key__[25][17]);
  cipher__[18] = XOR(tmp__[18],key__[25][18]);
  cipher__[19] = XOR(tmp__[19],key__[25][19]);
  cipher__[20] = XOR(tmp__[20],key__[25][20]);
  cipher__[21] = XOR(tmp__[21],key__[25][21]);
  cipher__[22] = XOR(tmp__[22],key__[25][22]);
  cipher__[23] = XOR(tmp__[23],key__[25][23]);
  cipher__[24] = XOR(tmp__[24],key__[25][24]);
  cipher__[25] = XOR(tmp__[25],key__[25][25]);
  cipher__[26] = XOR(tmp__[26],key__[25][26]);
  cipher__[27] = XOR(tmp__[27],key__[25][27]);
  cipher__[28] = XOR(tmp__[28],key__[25][28]);
  cipher__[29] = XOR(tmp__[29],key__[25][29]);
  cipher__[30] = XOR(tmp__[30],key__[25][30]);
  cipher__[31] = XOR(tmp__[31],key__[25][31]);
  cipher__[32] = XOR(tmp__[32],key__[25][32]);
  cipher__[33] = XOR(tmp__[33],key__[25][33]);
  cipher__[34] = XOR(tmp__[34],key__[25][34]);
  cipher__[35] = XOR(tmp__[35],key__[25][35]);
  cipher__[36] = XOR(tmp__[36],key__[25][36]);
  cipher__[37] = XOR(tmp__[37],key__[25][37]);
  cipher__[38] = XOR(tmp__[38],key__[25][38]);
  cipher__[39] = XOR(tmp__[39],key__[25][39]);
  cipher__[40] = XOR(tmp__[40],key__[25][40]);
  cipher__[41] = XOR(tmp__[41],key__[25][41]);
  cipher__[42] = XOR(tmp__[42],key__[25][42]);
  cipher__[43] = XOR(tmp__[43],key__[25][43]);
  cipher__[44] = XOR(tmp__[44],key__[25][44]);
  cipher__[45] = XOR(tmp__[45],key__[25][45]);
  cipher__[46] = XOR(tmp__[46],key__[25][46]);
  cipher__[47] = XOR(tmp__[47],key__[25][47]);
  cipher__[48] = XOR(tmp__[48],key__[25][48]);
  cipher__[49] = XOR(tmp__[49],key__[25][49]);
  cipher__[50] = XOR(tmp__[50],key__[25][50]);
  cipher__[51] = XOR(tmp__[51],key__[25][51]);
  cipher__[52] = XOR(tmp__[52],key__[25][52]);
  cipher__[53] = XOR(tmp__[53],key__[25][53]);
  cipher__[54] = XOR(tmp__[54],key__[25][54]);
  cipher__[55] = XOR(tmp__[55],key__[25][55]);
  cipher__[56] = XOR(tmp__[56],key__[25][56]);
  cipher__[57] = XOR(tmp__[57],key__[25][57]);
  cipher__[58] = XOR(tmp__[58],key__[25][58]);
  cipher__[59] = XOR(tmp__[59],key__[25][59]);
  cipher__[60] = XOR(tmp__[60],key__[25][60]);
  cipher__[61] = XOR(tmp__[61],key__[25][61]);
  cipher__[62] = XOR(tmp__[62],key__[25][62]);
  cipher__[63] = XOR(tmp__[63],key__[25][63]);

}

/* Additional functions */


/* **************************************************************** */
/*                            Usuba source                          */
/*                                                                  */
/*

 _no_inline table SubColumn_single(input :  v4)
  returns out :  v4
{
  6, 5, 12, 10, 1, 14, 7, 9, 11, 0, 3, 13, 8, 15, 4, 2
}


 node SubColumn(input :  b64)
  returns out :  b64
vars

let
  forall i in [0,15] {
    (out[i,(i + 16),(i + 32),(i + 48)]) = SubColumn_single(input[i,(i + 16),(i + 32),(i + 48)])
  }
tel

 node ShiftRows(input :  b16[4])
  returns out :  b16[4]
vars

let
  (out[0]) = input[0];
  (out[1]) = (input[1] <<< 1);
  (out[2]) = (input[2] <<< 12);
  (out[3]) = (input[3] <<< 13)
tel

 node Rectangle(plain :  b64,key : const b64[26])
  returns cipher :  b64
vars
  tmp :  b64[26]
let
  (tmp[0]) = plain;
  _no_unroll forall i in [0,24] {
    (tmp[(i + 1)]) = ShiftRows(SubColumn((tmp[i] ^ key[i])))
  };
  (cipher) = (tmp[25] ^ key[25])
tel

*/
 