#!/usr/bin/perl

use strict;
use warnings;

use FindBin;

=head1 SECTION 3.2 BENCHES

This section presents the common parts of the benchs for section 3.2.

=over

=item

B<Core technical details>

    The actual measurements are done by the files main_speed.c. They
    use
    [_rdtsc](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=rdtsc&expand=4512)
    to accurately measure cycles.  They run NB_LOOP (default 100000)
    encryptions of a BUFF_SIZE (default 4096) bytes buffer.

    All the benchmarks main outputs are .tex files, which contain
    macro that contain to the numbers reported in the paper.
   
    Note that when the code size is decreased by an
    optimization instead of increased (for instance, it is the case
    when inlining DES), the macro generated contains a negative
    number. However, we reformated those number in order to have them
    positive instead of negative in the paper (thus allowing us to say
    something like "... while actually reducing code size by xx%";
    which wouldn't have be possible with negative numbers).

    The results are in the "results" folders of each bench.

=item

B<Customization>

    The benchs are ran $NB_LOOP times (defined at the begining of
    run.pl, default to 20). It will usually take each of them up to a
    few minutes to run.

    The script has 3 parts, controlable through command line flags:
     * -g: regenerate the C codes from the Usuba sources. (not by default)
     * -c: recompile the C binaries (default).
     * -r: run the benchmark (default).

=back

=cut
    






=head1 INTERLEAVING

=over

=item 

B<Paper>: section 3.2 Back-end, paragraph Interleaving

=item 

B<bench directory>: bench/interleaving

=item 

B<bench run script>: bench/interleaving/run.pl.  


=item 

B<High-level description>

    The benchs runs interleaved and non-interleaved versions of
    Serpent and Rectangle generated by Usuba, and generates the file
    results/interleaving.tex which contains the speedup and binary
    size increase due to interleaving. 
    It will also generate results/{serpent.txt,rectangle.txt} which
    contains the details of each measurement (those numbers will also
    be printed on stdout).
    

=item

B<Specific details>

    The C codes generated by Usuba are already present in the
    directory (the files names xxx_ua.c). They can however be
    recompiled; see bellow using the -g flag.  The other C files are
    runtime stuffs (stream.c, *.h, serpent.c, key.c, ...).

=back

=cut

chdir "$FindBin::Bin";
chdir "interleaving";
system "./run.pl @ARGV";








=head1 SCHEDULING

=over

=item 

B<Paper>: section 3.2 Back-end, paragraph Scheduling bitsliced code

=item 

B<bench directory>: bench/scheduling-bs

=item 

B<bench run script>: bench/scheduling-bs/run.pl.  


=item 

B<High-level description>

    This bench compares the codes generated by usuba for bitsliced DES
    and AES, with and without scheduling.
    It generates the file results/scheduling-bs.tex, which contains
    the macros \SchedulingBitslice***Speedup (speedup gained by
    scheduling on cipher ***) and \SchedulingBitslice***Code (code
    size increase/decreased due to scheduling on cipher ***). Those
    numbers come in the paper right after "On bitsliced DES, scheduling
    after inlining increases throughput by...".

    
=item

B<Specific details>

    What to look at in run.pl: 
    lines 57-58: generates C code from usuba
    code without (-no-sched) and with (no options; scheduling is done
    by default) scheduling.
    lines 68-69: compiles the binaries for the bench (with and without 
    scheduling)
    lines 85-89: run the benchs, stores the results.
    lines 95-104: print measurements to stdout (and to the .txt files)
    lines 106-113: computes the speedup/sizes.
    lines 117-end: prints the results.

=back

=cut
    
chdir "$FindBin::Bin";
chdir "scheduling-bs";
system "./run.pl @ARGV";







=head1 INLINING

=over

=item 

B<Paper>: section 3.2 Back-end, paragraphs Inlining, Scheduling bitsliced code and Scheduling m-sliced code

=item 

B<bench directory>: bench/inlining


=item 

B<bench run script>: bench/inlining/run.pl.  


=item 

B<High-level description>

    This bench generates the file results/inlining-nosched.tex and
    results/inlining-sched.tex, which contain the following macros:
    * inlining-nosched.tex: (bitsliced ciphers only, no inlining)
      - \InliningNosched***Speedup: the speedup offered by inlining in cipher ***
      - \InliningNosched***Code: the increase/decrease in code size caused by inlining
    * inlining-sched.tex:
      This might be confusing, but the meaning of Scheduling in this file depends on
      the cipher (the slicing type actually): for AES and DES (bitsliced), it is 
      bitslice scheduling, whereas for Chacha20 and AES H-sliced, it is m-slice 
      scheduling.
      - \InliningScheduling***Speedup: the speedup offered by inlining and scheduling
      - \InliningScheduling***Code: the increase/decrease in code size caused by inlining

    More specifically, the numbers of the paragraph Inlining are
    \InliningNoschedDESSpeedup (44.8), \InliningNoschedDESCode (9.1),
    \InliningNoschedAESSpeedup (24.24), and \InliningNoschedAESCode
    (24.8) (in that order). 
    Paragraph Scheduling bisliced code: only the last two numbers
    ("Overall, comining inlining and scheduling reults in a net..")
    are generated by this benchs (the previous four number are
    generated by bench/scheduling/run.pl):
    \InliningSchedulingDESSpeedup (45.8) \InliningSchedulingAESSpeedup
    (26.22).
    Paragraph Scheduling m-sliced code: only the first two number are
    generated by this bench ("This scheduling algorithm increased the
    throughput of ..."): \InliningSchedulingHAESSpeedup (2.43) and
    \InliningSchedulingChachaSpeedup (9.09).

    The details of each measurements are available in results/*.txt,
    and are printed to stdout during the bench, though you shouldn't
    need them.

=item

B<Specific details>

    I'll run you quickly through the script bench/inlining/run.pl so
    you can understand what happens.

    lines 32-44: ciphers for the bench, and their slicing types.

    C file generation:
    line 61: $sched_opt will be either -no-sched (ie, don't perform scheduling),
    or '-sched-n 10' (ie, perform scheduling, and sets the lookahead window to 
    10 for the m-slice scheduling).
    line 65-66: compiles the Usuba codes, either without inlining (-no-inline),
    or with inlining (-inline-all).

    C file compilation:
    lines 75-80: compile each cipher for each combination of scheduling/inlining

    Benchmark run:
    line 95-98: runs each binary for each cipher (l.88, for my $cipher),  each 
    scheduling (l.87, for my $sched), and each inlining (l.94, for my $inline),
    and stores the results inside the hash %res.
    line 104-113: generates the .txt files (which contains the details of the
    measurements).
    line 115-122: computes the speedups, and code size ratios.
    line 126-end: generates the .tex files, containing the numbers computed above.

=back

=cut

    
chdir "$FindBin::Bin";
chdir "inlining";
system "./run.pl @ARGV";






=head1 UNROLLING

=over

=item 

B<Paper>: section 3.2 Back-end, paragraph Scheduling m-sliced code

=item 

B<bench directory>: bench/unrolling

=item 

B<bench run script>: bench/unrolling/run.pl.  


=item 

B<High-level description>

    This bench compares the codes generated by usuba for m-sliced AES
    and Chacha20.
    It generates the file results/unrolling.tex, which contains the
    macros \Unrolling***Speedup (speedup gained by unrolling cipher
    ***) and \Unrolling***Code (code size increase/decreased due to
    unrolling cipher ***). Those numbers come in the paper at the end
    of the paragraph Scheduling m-sliced code, right after "On AES
    (resp. Chacha20), this yields a ...".

    
=item

B<Specific details>

    What to look at in run.pl: 
    lines 60-61: generates C code from usuba code without (no options;
    unroll is not done by default) and with (-unroll) unrolling.
    Note that scheduling and inlining are enabled (line 56).
    lines 71-72: compiles the binaries for the bench (with and without 
    unrolling)
    lines 88-94: run the benchs, stores the results.
    lines 98-107: print measurements to stdout (and to the .txt files)
    lines 109-116: computes the speedup/sizes.
    lines 119-end: prints the results.

=back

=cut
    
chdir "$FindBin::Bin";
chdir "unrolling";
system "./run.pl @ARGV";
