/* This code was generated by Usuba.
   See https://github.com/DadaIsCrazy/usuba.
   From the file "samples/usuba/rectangle_vector.ua" (included below). */

#include <stdint.h>

/* Do NOT change the order of those define/include */
#define NO_RUNTIME
#ifndef BITS_PER_REG
#define BITS_PER_REG 128
#endif
/* including the architecture specific .h */
#include "SSE.h"

/* auxiliary functions */


/* main function */
void Rectangle__ (/*inputs*/ DATATYPE plain__[4],DATATYPE key__[26][4], /*outputs*/ DATATYPE cipher__[4]) {
  
  // Variables declaration
  DATATYPE SubColumn___1_t1;
  DATATYPE SubColumn___1_t11;
  DATATYPE SubColumn___1_t2;
  DATATYPE SubColumn___1_t3;
  DATATYPE SubColumn___1_t5;
  DATATYPE SubColumn___1_t6;
  DATATYPE SubColumn___1_t8;
  DATATYPE SubColumn___1_t9;
  DATATYPE _tmp1_[4];
  DATATYPE _tmp2_[4];
  DATATYPE tmp__[4];

  // Instructions (body)
  tmp__[0] = plain__[0];
  tmp__[1] = plain__[1];
  tmp__[2] = plain__[2];
  tmp__[3] = plain__[3];
  for (int i = 0; i <= 24; i++) {
    _tmp1_[0] = XOR(tmp__[0],key__[i][0]);
    _tmp1_[1] = XOR(tmp__[1],key__[i][1]);
    _tmp1_[2] = XOR(tmp__[2],key__[i][2]);
    _tmp1_[3] = XOR(tmp__[3],key__[i][3]);
    SubColumn___1_t1 = NOT(_tmp1_[1]);
    SubColumn___1_t8 = XOR(_tmp1_[1],_tmp1_[2]);
    SubColumn___1_t3 = XOR(_tmp1_[2],_tmp1_[3]);
    SubColumn___1_t2 = AND(_tmp1_[0],SubColumn___1_t1);
    SubColumn___1_t5 = OR(_tmp1_[3],SubColumn___1_t1);
    _tmp2_[0] = XOR(SubColumn___1_t2,SubColumn___1_t3);
    SubColumn___1_t6 = XOR(_tmp1_[0],SubColumn___1_t5);
    SubColumn___1_t11 = OR(_tmp2_[0],SubColumn___1_t8);
    tmp__[0] = _tmp2_[0];
    _tmp2_[1] = XOR(_tmp1_[2],SubColumn___1_t6);
    SubColumn___1_t9 = AND(SubColumn___1_t3,SubColumn___1_t6);
    _tmp2_[2] = XOR(SubColumn___1_t6,SubColumn___1_t11);
    tmp__[1] = L_ROTATE(_tmp2_[1],1,16);
    _tmp2_[3] = XOR(SubColumn___1_t8,SubColumn___1_t9);
    tmp__[2] = L_ROTATE(_tmp2_[2],12,16);
    tmp__[3] = L_ROTATE(_tmp2_[3],13,16);
  }
  cipher__[0] = XOR(tmp__[0],key__[25][0]);
  cipher__[1] = XOR(tmp__[1],key__[25][1]);
  cipher__[2] = XOR(tmp__[2],key__[25][2]);
  cipher__[3] = XOR(tmp__[3],key__[25][3]);

}


/* **************************************************************** */
/*                            Usuba source                          */
/*                                                                  */
/*

_no_inline table SubColumn(input :  u16x4 :: base)
  returns out :  u16x4 :: base
{
  6, 5, 12, 10, 1, 14, 7, 9, 11, 0, 3, 13, 8, 15, 4, 2
}


 node ShiftRows(input :  u16x4 :: base)
  returns out :  u16x4 :: base
vars

let
  (out[0]) = input[0];
  (out[1]) = (input[1] <<< 1);
  (out[2]) = (input[2] <<< 12);
  (out[3]) = (input[3] <<< 13)
tel

 node Rectangle(plain :  u16x4 :: base,key : const u16x4[26] :: base)
  returns cipher :  u16x4 :: base
vars
  tmp :  u16x4[26] :: base
let
  (tmp[0]) = plain;
  _no_unroll forall i in [0,24] {
    (tmp[(i + 1)]) = ShiftRows(SubColumn((tmp[i] ^ key[i])))
  };
  (cipher) = (tmp[25] ^ key[25])
tel

*/
 